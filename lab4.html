<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSM - Página de Relatórios</title>
    <script src="js/main.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@300&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/main.css">
</head>
<body>
    <header>
        <h1>Laboratório <span id="csm">4</span></h1>
    </header>

    <section>
            <div id="arealab">
                <p class="titlelab">1. Objetivos</p>
                <p class="textlab">
                    Este laboratório tem os seguintes objetivos:
                    <ul class="textlabul">
                        <li>Efetuar a codificação de imagem e a decodificação por DWT e IDWT;</li>
                        <li>Testar funções de codificação multinível;</li>
                        <li>Verificar a taxa de compressão só com a componente de aproximação.</li>
                    </ul>
                </p>

                <p class="textlab">Obs.: Para este laboratório não foi fornecido um roteiro em PDF, mas o notebook fornecido já continha o passo a passo bem definido.</p>
                <br>

                <p class="titlelab">2. Desenvolvimento</p>
                <p class="textlab">
                    Para o desenvolvimento deste laboratório, foi utilizado o Jupyter Notebook fornecido e editado no Google Colab. 
                    O arquivo final pode ser visualizado <a href="https://colab.research.google.com/drive/1MsnaDOQ9EfpIokp5XRKmok56_-c67BjS">neste link.</a>
                </p>
                
                <p class="textlab">   
                    Inicialmente foram importadas as bibliotecas necessárias e realizado o download dos arquivos das imagens originais a serem codificadas ao longo do laboratório. 
                    Este procedimento é semelhante ao que já foi executado anteriormente nos demais laboratórios.
                </p>

                <p class="textlab">
                    A primeira codificação executada foi a conversão das imagens para P&B (codificação de luminância), usando a função 
                    <a href="https://docs.opencv.org/4.5.3/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab">cv.cvtColor()</a>. 
                    Além disso, foi aplicado a Transformada Discreta de Wavelet (DWT) para separação dos coeficientes, com a função <a href="https://pywavelets.readthedocs.io/en/latest/ref/2d-dwt-and-idwt.html">pywt.dwt2()</a>.
                    O resulado pode ser visualizado nas imagens abaixo:
                </p>
                
                <p style="text-align:center" class="textlab">
                    <img src="lab4/fotos_Y_DWT.jpg" class="imgs">
                    <img src="lab4/fotos_Cb_DWT.jpg" class="imgs">
                    <img src="lab4/fotos_Cr_DWT.jpg" class="imgs">
                    <img src="lab4/heitor_Y_DWT.jpg" class="imgs">
                    <img src="lab4/heitor_Cb_DWT.jpg" class="imgs">
                    <img src="lab4/heitor_Cr_DWT.jpg" class="imgs">
                    <img src="lab4/luiz_Y_DWT.jpg" class="imgs">
                    <img src="lab4/luiz_Cb_DWT.jpg" class="imgs">
                    <img src="lab4/luiz_Cr_DWT.jpg" class="imgs">
                </p>

                <p class="textlab">
                    É importante observar que, para melhor organização, as imagens foram criadas na sequência (lado a lado): Aproximação (CA); Bordas Verticais (CV); Bordas Horizontais (CH); e Bordas Diagonais (CD). 
                    Além disso, nota-se que a mesma imagem foi convertida previamente para luma-chroma (YCrCb separadas), apresentadas em sequência: Y, Cr e Cb, uma abaixo da outra para cada uma das fotos originais.
                </p>

                <p class="textlab">
                    Foi calculado o erro quadrático médio (MSE) e a Relação Sinal Ruído de Pico (PSNR). 
                    O MSE é obtido somando-se o erro quadrático de reconstrução pixel a pixel entre a Imagem Original e a Reconstruída e normalizando pela dimensão (LxA) da imagem:
                    <br><br>
                    $MSE = \frac{1}{LA} \sum_{i=0}^{L}\sum_{j=0}^{A} \left[ O(i,j) - R(i,j) \right] ^2$
                    <br><br>
                    Já a PSNR é definida para cada plano componente da imagem como:
                    <br><br>
                    $PSNR = 10\log_{10} \left( \frac{MAX_I^2}{MSE}\right)$
                    <br><br>
                    sendo $MAXI$ o valor máximo do pixel, que para 8 bits equivale a 255, logo:
                    <br><br>
                    $PSNR = 20\log_{10} \left( 255 \right) - 10\log_{10} \left( MSE \right)$
                    <br><br>
                    OBS.: Para uma imagem RGB, $MSE = MSER + MSEG + MSEB$, sendo similar definiação para YCrCb e HSV.
                </p>


                <p class="titlelab">3. Conclusões</p>
                <p class="textlab">
                    ...
                </p>
            </div>
    </section>

    <section>
        <div id="link">
            <h4><a href="index.html">VOLTAR</a></h4>
        </div>
        <br>
    </section>

    <footer>
        <h5>ESTI019 – Codificação de Sinais Multimídia - Alunos: Heitor Rodrigues e Luiz Bitencourt - Setembro/2021</h5>
    </footer>
</body>
</html>